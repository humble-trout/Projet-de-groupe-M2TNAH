BEGIN;

-- nom de schéma définitif
SET search_path TO test_psch;

--supprime les tables si elles existent déjà, pour nos tests

DROP TABLE IF EXISTS tmp_cnc, tmp_etab_cine, tmp_programmation, tmp_rsa, tmp_wiki1, tmp_wiki2, tmp_titre;

--jeux de données du CNC sur les cinéma

-- correction de la qualité, majoritairement des attributs non reconnus comme int et maj/espace/
-- on ne corrige pas en profondeur les champs qu'on n'utilisera pas

CREATE TABLE IF NOT EXISTS tmp_cnc AS (
SELECT 
    CAST(rc."régionCNC"::TEXT AS INTEGER) AS region_cnc,
    CAST(rc."N° auto" AS INTEGER) AS n_auto,
    TRIM(INITCAP(rc.nom)) AS nom_cinema,
    TRIM(INITCAP(rc."région administrative")) AS region_administrative,
    TRIM(INITCAP(rc.adresse)) AS adresse,
    CAST(rc."code INSEE" AS INTEGER) AS code_insee,
    rc.commune AS commune,
    rc."population de la commune" AS population_commune,
    CAST(CASE 
        	WHEN Trim(rc."DEP"::TEXT) IN ('2A', '2B') THEN '20'
        	ELSE rc."DEP"::TEXT
    	END AS INTEGER) AS departement, 
    rc."N°UU" AS n_uu,
    rc."unité urbaine" AS unite_urbaine, 
    CAST(rc."population unité urbaine" AS INTEGER) AS population_unite_urbaine, 
    rc."situation géographique" AS situation_geographique, 
    CAST(rc."écrans" AS INTEGER) AS ecrans, 
    CAST(rc.fauteuils AS INTEGER) AS fauteuils, 
    CAST(rc."semaines d'activité" AS INTEGER) AS semaines_activite, 
    CAST(REGEXP_REPLACE(rc."séances"::TEXT, '[^0-9]', '', 'g') AS INTEGER) AS seances_annuelles, 
    CAST(REGEXP_REPLACE(rc."entrées 2024"::TEXT, '[^0-9]', '', 'g') AS INTEGER) AS entree_24, 
    CAST(REGEXP_REPLACE(NULLIF(rc."entrées 2023"::TEXT, ''), '[^0-9]', '', 'g') AS INTEGER) AS entree_23,
    rc."évolution entrées" AS evolution_entrees, 
    rc."tranche d'entrées" AS tranche_entrees, 
    rc."propriétaire" AS proprietaire, 
    CAST(CASE WHEN rc."AE" = 'OUI' THEN TRUE ELSE FALSE END AS BOOLEAN) AS art_et_essai, 
    rc."catégorie Art et Essai" AS categorie_ae, 
    rc."label Art et Essai" AS label_ae, 
    rc.genre AS genre, 
    CAST(CASE WHEN rc.multiplexe = 'OUI' THEN TRUE ELSE FALSE END AS BOOLEAN) AS multiplexe,
    rc."zone de la commune" AS zone_commune, 
    CAST(rc."nombre de films programmés" AS INTEGER) AS nb_films_programmes, 
    CAST(rc."nombre de films inédits" AS INTEGER) AS nb_films_inedits, 
    CAST(rc."nombre de films en semaine 1" AS INTEGER) AS nb_films_semaine_1, 
    CAST(REGEXP_REPLACE(REPLACE(rc."PdM en entrées des films français"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS pdm_films_francais, 
    CAST(REGEXP_REPLACE(REPLACE(rc."PdM en entrées des films américains"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS pdm_films_americains, 
    CAST(REGEXP_REPLACE(REPLACE(rc."PdM en entrées des films européens"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS pdm_films_europeens, 
    CAST(REGEXP_REPLACE(REPLACE(rc."PdM en entrées des autres films"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS pdm_autres_films, 
    CAST(rc."films Art et Essai" AS INTEGER) AS nb_films_ae, 
    CAST(REGEXP_REPLACE(REPLACE(rc."part des séances de films Art et Essai"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS part_seances_ae, 
    CAST(REGEXP_REPLACE(REPLACE(rc."PdM en entrées des films Art et Essai"::TEXT, ',', '.'), '[^0-9.]', '', 'g') AS REAL) AS pdm_films_ae,
    CAST(rc.latitude AS REAL) AS latitude, 
    CAST(rc.longitude AS REAL) AS longitude
FROM raw_cnc rc );

-- jeux de données sur les cinémas de data.gouv

	-- jeux extremement similaire au précédent donc traitement similaire, mais la reconnaissance du type etaot plus simple


CREATE TABLE IF NOT EXISTS tmp_etab_cine AS (
SELECT 
    CAST(re."régionCNC"::TEXT AS INTEGER) AS region_cnc,
    CAST(re."N° auto" AS INTEGER) AS n_auto,
    TRIM(INITCAP(re.nom)) AS nom_cinema,
    TRIM(INITCAP(re."région administrative")) AS region_administrative,
    TRIM(INITCAP(re.adresse)) AS adresse,
    CAST(re."code INSEE" AS INTEGER) AS code_insee,
    re.commune AS commune,
    re."population de la commune" AS population_commune,
    CAST(TRIM(re."DEP"::TEXT) AS INTEGER) AS departement, 
    re."N°UU" AS n_uu,
    re."unité urbaine" AS unite_urbaine, 
    CAST(re."population unité urbaine" AS INTEGER) AS population_unite_urbaine, 
    re."situation géographique" AS situation_geographique, 
    CAST(re."écrans" AS INTEGER) AS ecrans, 
    CAST(re.fauteuils AS INTEGER) AS fauteuils, 
    CAST(re."semaines d'activité" AS INTEGER) AS semaines_activite, 
    CAST(re."séances" AS FLOAT) AS seances,
    CAST(re."entrées 2022" AS INTEGER) AS entree_22,
    CAST(re."entrées 2021" AS INTEGER) AS entree_21,
    re."évolution entrées" AS evolution_entrees, 
    re."tranche d'entrées" AS tranche_entrees, 
    re."programmateur" AS programmateur, 
    CAST(CASE WHEN re."AE" = 'OUI' THEN TRUE ELSE FALSE END AS BOOLEAN) AS art_et_essai, 
    re."catégorie Art et Essai" AS categorie_ae, 
    re."label Art et Essai" AS label_ae, 
    re.genre AS genre, 
    CAST(CASE WHEN re.multiplexe = 'OUI' THEN TRUE ELSE FALSE END AS BOOLEAN) AS multiplexe,
    re."zone de la commune" AS zone_commune, 
    CAST(re."nombre de films programmés" AS INTEGER) AS nb_films_programmes, 
    CAST(re."nombre de films inédits" AS INTEGER) AS nb_films_inedits, 
    CAST(re."nombre de films en semaine 1" AS INTEGER) AS nb_films_semaine_1, 
    CAST(re."PdM en entrées des films français" AS REAL) AS pdm_films_francais, 
    CAST(re."PdM en entrées des films américains" AS REAL) AS pdm_films_americains, 
    CAST(re."PdM en entrées des films européens" AS REAL) AS pdm_films_europeens, 
    CAST(re."PdM en entrées des autres films" AS REAL) AS pdm_autres_films, 
    CAST(re."films Art et Essai" AS INTEGER) AS nb_films_ae, 
    CAST(re."PdM en entrées des films Art et Essai" AS REAL) AS pdm_films_ae,
    CAST(re.latitude AS REAL) AS latitude, 
    CAST(re.longitude AS REAL) AS longitude
FROM raw_etab_cine re );


-- jeux de données sur la programmation des cinémas indépendants
	-- le traitement est plus léger car les données concernant les films eux meme proviendront a terme d'un csv different

CREATE TABLE IF NOT EXISTS tmp_programmation AS (
SELECT
	INITCAP(TRIM(REGEXP_REPLACE(rp.filmtitle, '[^a-zA-Z ]', '', 'g'))) AS titre,
	INITCAP(TRIM(rp.filmdirector)) AS realisateur,
	INITCAP(TRIM(rp.filmcast)) AS distribution,
    CAST(rp.filmstoryline AS TEXT) AS resume,
    rp.filmgenre AS genre,
    rp.filmcountry AS pays_film,
    CAST(NULLIF(rp.showstart, '') AS TIMESTAMPTZ) AS debut_seance,
    CAST(NULLIF(rp.showend, '') AS TIMESTAMPTZ) AS fin_seance,
    rp.evenement,
    rp.auditoriumnumber AS salle,
    CASE 
    	WHEN TRIM(rp.filmversion) IN ('VERSION_ORIGINAL', 'VERSION_ORIGINAL_LOCAL') THEN 'VO'
        WHEN TRIM(rp.filmversion) = 'VERSION_LOCAL' THEN 'VF'
        ELSE TRIM(rp.filmversion)
    END AS version_audio,
    CAST(CASE WHEN rp.filmaudio = 'ST' THEN TRUE ELSE FALSE END AS BOOLEAN) AS sous_titres,
   	rp.filmtrailer AS bande_annonce,
   	rp.filmposter AS affiche,
   	rp.showid,
   	rp.filmid,
   	rp.showurl AS reservation,
   	rp.cineid,
   	TRIM(INITCAP(rp.cinenom )) AS nom_cinema,
   	TRIM(INITCAP(rp.cineadresse)) AS adresse,
   	(rp.cinecp / 1000) AS departement,
   	TRIM(INITCAP(rp.cineville)) AS ville,
   	rp.description,
   	rp.auditoriumcapacity AS nbr_place
FROM raw_prog rp);
	
	
-- jeux de données sur le RSA	

CREATE TABLE IF NOT EXISTS tmp_rsa AS (
SELECT
	CAST(rsa."Date référence" || '-01' AS DATE) AS date_ref,
	TRIM(rsa."Numéro commune") AS num_commune,
	TRIM(rsa."Type RSA")  AS type_rsa,
	TRIM(INITCAP(rsa."Nom commune")) AS commune,
	rsa."Nombre foyers RSA" AS nbr_foyer_rsa,
	rsa."Nombre personnes RSA" AS nbr_pers_rsa
FROM raw_rsa rsa);


-- jeux de données wikidata, informations sur les films

CREATE TABLE IF NOT EXISTS tmp_wiki1 AS (
SELECT 
    rw.film AS film_entity,
    INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rw."filmLabel", '^Q[0-9]+$', ''), ''))) AS titre,
	INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rw."realisateurLabel", '^Q[0-9]+$', ''), ''))) AS realisateur,
    rw.duree,
    INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rw."genreLabel", '^Q[0-9]+$', ''), ''))) AS genre,
    EXTRACT(YEAR FROM (NULLIF(rw."dateLabel", '')::TIMESTAMP))::INTEGER AS annee_sortie,
    (CASE
            WHEN rw."note" ~ '^[0-9]+(\.[0-9]+)?%$' THEN REPLACE(rw."note", '%', '')::numeric
            WHEN rw."note" ~ '^[0-9]+(\.[0-9]+)?/100$' THEN SPLIT_PART(rw."note", '/', 1)::numeric
            WHEN rw."note" ~ '^[0-9]+(\.[0-9]+)?/10$' THEN SPLIT_PART(rw."note", '/', 1)::NUMERIC * 10
            WHEN rw."note" ~ '^[0-9]+(\.[0-9]+)?$' AND rw."note"::NUMERIC <= 10 THEN rw."note"::NUMERIC * 10
            WHEN rw."note" ~ '^[0-9]+(\.[0-9]+)?$' THEN rw."note"::NUMERIC
            ELSE NULL
    END)::INTEGER AS note_sur_100
FROM raw_wikidata1 rw);



-- le script est doublé par ce que le csv a du etre scindé en deux car trop lourd
CREATE TABLE IF NOT EXISTS tmp_wiki2 AS (
SELECT 
    rd.film AS film_entity,
    INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rd."filmLabel", '^Q[0-9]+$', ''), ''))) AS titre,
    INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rd."realisateurLabel", '^Q[0-9]+$', ''), ''))) AS realisateur,
    rd.duree,
    INITCAP(TRIM(NULLIF(REGEXP_REPLACE(rd."genreLabel", '^Q[0-9]+$', ''), ''))) AS genre,
    EXTRACT(YEAR FROM (NULLIF(rd."dateLabel", '')::TIMESTAMP))::INTEGER AS annee_sortie,
    (CASE
            WHEN rd."note" ~ '^[0-9]+(\.[0-9]+)?%$' THEN REPLACE(rd."note", '%', '')::numeric
            WHEN rd."note" ~ '^[0-9]+(\.[0-9]+)?/100$' THEN SPLIT_PART(rd."note", '/', 1)::numeric
            WHEN rd."note" ~ '^[0-9]+(\.[0-9]+)?/10$' THEN SPLIT_PART(rd."note", '/', 1)::NUMERIC * 10
            WHEN rd."note" ~ '^[0-9]+(\.[0-9]+)?$' AND rd."note"::NUMERIC <= 10 THEN rd."note"::NUMERIC * 10
            WHEN rd."note" ~ '^[0-9]+(\.[0-9]+)?$' THEN rd."note"::NUMERIC
            ELSE NULL
    END)::INTEGER AS note_sur_100
FROM raw_wikidata2 rd
);

--crée une table temporaire pour les titres de film. permet d'éviter des doublons pour des films qui ont plusieurs réalisateurs, genres, etc.
CREATE TABLE if not exists TMP_titre AS (
    -- importation du premier csv Wikidata
    SELECT TRIM(INITCAP("filmLabel")) AS titre
    FROM raw_wikidata1
    WHERE "filmLabel" !~ 'Q[^a-z]'
    UNION -- Fusionne et supprime les doublons automatiquement
    -- importation du second csv Wikidata
    SELECT TRIM(INITCAP("filmLabel"))
    FROM raw_wikidata2
    WHERE "filmLabel" !~ 'Q[^a-z]'
    UNION
    -- importation du csv raw_prog
    SELECT TRIM(INITCAP(filmtitle))
    FROM raw_prog
    WHERE filmtitle IS NOT NULL AND filmtitle != ''
);

--crée une colonne id_film dans films_realisateurs qui génère automatiquement une ID
ALTER TABLE TMP_titre 
ADD COLUMN id_film INTEGER GENERATED ALWAYS AS IDENTITY;

--transforme cette colonne en clé primaire
ALTER TABLE TMP_titre 
ADD PRIMARY KEY (id_film);

COMMIT ;
